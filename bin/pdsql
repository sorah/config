#!/usr/bin/env ruby
require 'bundler/inline'
require 'optparse'
gemfile do
  source 'https://rubygems.org' 
  gem 'aws-sdk-dsql'
end

host = ENV['PGHOST']
role = ENV['PGUSER'] || 'admin'

opt = OptionParser.new() do |o|
  o.on('-h', '--host HOST', 'DSQL Host') { host = _1 }
  o.on('-U', '--username USER', 'role') { role = _1 }
end

opt.parse(ARGV.dup)
host_match = host.match(/\A(?<id>[a-z0-9-]+)\.dsql\.(?<region>[a-z0-9-]+).on\.aws\z/) or abort "Invalid DSQL host format #{host.inspect}"
region = host_match[:region]

@dsql = Aws::DSQL::Client.new
token_generator = Aws::DSQL::AuthTokenGenerator.new(credentials: @dsql.config.credentials)


password_token = {
  endpoint: host,
  region:,
  expires_in: 3600,
}.then do |params|
  case role
  when "admin"
    token_generator.generate_db_connect_admin_auth_token(params)
  else
    token_generator.generate_db_connect_auth_token(params)
  end 
end

pgpassfile = Tempfile.new('pgpass').tap do |f|
  f.write("*:*:*:#{role}:#{password_token}\n")
  f.flush
end
ObjectSpace.undefine_finalizer(pgpassfile)
ENV['PGPASSFILE'] = pgpassfile.path
ENV['PGPASSWORD'] = password_token
ENV['PGSSLMODE'] = 'verify-full'
#ENV['PGSSLCERTMODE'] = 'require'
ENV['PGSSLROOTCERT'] = '/etc/ssl/certs/ca-bundle.crt'.then { File.exist?(_1) ? _1: 'system' }
ENV['PGDATABASE'] = 'postgres'
ENV['PGUSER'] = role

if ARGV[0] == '--'
  ARGV.shift
  exec(*ARGV)
else
  exec 'psql', *ARGV
end
